import { renderHook, waitFor } from '@testing-library/react'
import { QueryClient, QueryClientProvider } from '@tanstack/react-query'
import { useMemories, useCreateMemory, useUpdateMemory, useDeleteMemory } from '../useMemories'
import { mcpAdapter } from '@/services/api/mcp-adapter'
import { mockMemory } from '@/utils/test-helpers'

// Mock the MCP adapter
jest.mock('@/services/api/mcp-adapter')
const mockMcpAdapter = mcpAdapter as jest.Mocked<typeof mcpAdapter>

// Test wrapper with React Query
const createWrapper = () => {
  const queryClient = new QueryClient({
    defaultOptions: {
      queries: { retry: false },
      mutations: { retry: false }
    }
  })\n  \n  return ({ children }: { children: React.ReactNode }) => (\n    <QueryClientProvider client={queryClient}>\n      {children}\n    </QueryClientProvider>\n  )\n}\n\ndescribe('Memory Hooks', () => {\n  beforeEach(() => {\n    jest.clearAllMocks()\n  })\n\n  describe('useMemories', () => {\n    it('fetches memories successfully', async () => {\n      const mockMemories = {\n        memories: [mockMemory(), mockMemory({ id: 'memory-2' })],\n        total: 2\n      }\n\n      mockMcpAdapter.memory.getMemories.mockResolvedValueOnce(mockMemories)\n\n      const { result } = renderHook(() => useMemories(), {\n        wrapper: createWrapper()\n      })\n\n      await waitFor(() => {\n        expect(result.current.isSuccess).toBe(true)\n      })\n\n      expect(result.current.data).toEqual(mockMemories)\n      expect(mockMcpAdapter.memory.getMemories).toHaveBeenCalledWith({})\n    })\n\n    it('passes filters to API', async () => {\n      const filters = { tags: ['test'], limit: 10 }\n      const mockMemories = { memories: [], total: 0 }\n\n      mockMcpAdapter.memory.getMemories.mockResolvedValueOnce(mockMemories)\n\n      const { result } = renderHook(() => useMemories(filters), {\n        wrapper: createWrapper()\n      })\n\n      await waitFor(() => {\n        expect(result.current.isSuccess).toBe(true)\n      })\n\n      expect(mockMcpAdapter.memory.getMemories).toHaveBeenCalledWith(filters)\n    })\n\n    it('handles fetch errors', async () => {\n      const error = new Error('Failed to fetch memories')\n      mockMcpAdapter.memory.getMemories.mockRejectedValueOnce(error)\n\n      const { result } = renderHook(() => useMemories(), {\n        wrapper: createWrapper()\n      })\n\n      await waitFor(() => {\n        expect(result.current.isError).toBe(true)\n      })\n\n      expect(result.current.error).toEqual(error)\n    })\n\n    it('shows loading state initially', () => {\n      mockMcpAdapter.memory.getMemories.mockImplementation(\n        () => new Promise(() => {}) // Never resolves\n      )\n\n      const { result } = renderHook(() => useMemories(), {\n        wrapper: createWrapper()\n      })\n\n      expect(result.current.isLoading).toBe(true)\n      expect(result.current.data).toBeUndefined()\n    })\n  })\n\n  describe('useCreateMemory', () => {\n    it('creates memory successfully', async () => {\n      const newMemory = mockMemory()\n      const memoryData = {\n        title: 'New Memory',\n        content: 'New content',\n        tags: ['new']\n      }\n\n      mockMcpAdapter.memory.createMemory.mockResolvedValueOnce(newMemory)\n\n      const { result } = renderHook(() => useCreateMemory(), {\n        wrapper: createWrapper()\n      })\n\n      result.current.mutate(memoryData)\n\n      await waitFor(() => {\n        expect(result.current.isSuccess).toBe(true)\n      })\n\n      expect(result.current.data).toEqual(newMemory)\n      expect(mockMcpAdapter.memory.createMemory).toHaveBeenCalledWith(memoryData)\n    })\n\n    it('handles creation errors', async () => {\n      const error = new Error('Failed to create memory')\n      mockMcpAdapter.memory.createMemory.mockRejectedValueOnce(error)\n\n      const { result } = renderHook(() => useCreateMemory(), {\n        wrapper: createWrapper()\n      })\n\n      result.current.mutate({\n        title: 'Test',\n        content: 'Test',\n        tags: []\n      })\n\n      await waitFor(() => {\n        expect(result.current.isError).toBe(true)\n      })\n\n      expect(result.current.error).toEqual(error)\n    })\n\n    it('shows loading state during creation', () => {\n      mockMcpAdapter.memory.createMemory.mockImplementation(\n        () => new Promise(() => {}) // Never resolves\n      )\n\n      const { result } = renderHook(() => useCreateMemory(), {\n        wrapper: createWrapper()\n      })\n\n      result.current.mutate({\n        title: 'Test',\n        content: 'Test',\n        tags: []\n      })\n\n      expect(result.current.isPending).toBe(true)\n    })\n  })\n\n  describe('useUpdateMemory', () => {\n    it('updates memory successfully', async () => {\n      const updatedMemory = mockMemory({ title: 'Updated Title' })\n      const updateData = {\n        id: 'memory-1',\n        title: 'Updated Title',\n        content: 'Updated content'\n      }\n\n      mockMcpAdapter.memory.updateMemory.mockResolvedValueOnce(updatedMemory)\n\n      const { result } = renderHook(() => useUpdateMemory(), {\n        wrapper: createWrapper()\n      })\n\n      result.current.mutate(updateData)\n\n      await waitFor(() => {\n        expect(result.current.isSuccess).toBe(true)\n      })\n\n      expect(result.current.data).toEqual(updatedMemory)\n      expect(mockMcpAdapter.memory.updateMemory).toHaveBeenCalledWith(\n        updateData.id,\n        { title: updateData.title, content: updateData.content }\n      )\n    })\n\n    it('handles update errors', async () => {\n      const error = new Error('Failed to update memory')\n      mockMcpAdapter.memory.updateMemory.mockRejectedValueOnce(error)\n\n      const { result } = renderHook(() => useUpdateMemory(), {\n        wrapper: createWrapper()\n      })\n\n      result.current.mutate({\n        id: 'memory-1',\n        title: 'Updated'\n      })\n\n      await waitFor(() => {\n        expect(result.current.isError).toBe(true)\n      })\n\n      expect(result.current.error).toEqual(error)\n    })\n  })\n\n  describe('useDeleteMemory', () => {\n    it('deletes memory successfully', async () => {\n      mockMcpAdapter.memory.deleteMemory.mockResolvedValueOnce(undefined)\n\n      const { result } = renderHook(() => useDeleteMemory(), {\n        wrapper: createWrapper()\n      })\n\n      result.current.mutate('memory-1')\n\n      await waitFor(() => {\n        expect(result.current.isSuccess).toBe(true)\n      })\n\n      expect(mockMcpAdapter.memory.deleteMemory).toHaveBeenCalledWith('memory-1')\n    })\n\n    it('handles deletion errors', async () => {\n      const error = new Error('Failed to delete memory')\n      mockMcpAdapter.memory.deleteMemory.mockRejectedValueOnce(error)\n\n      const { result } = renderHook(() => useDeleteMemory(), {\n        wrapper: createWrapper()\n      })\n\n      result.current.mutate('memory-1')\n\n      await waitFor(() => {\n        expect(result.current.isError).toBe(true)\n      })\n\n      expect(result.current.error).toEqual(error)\n    })\n  })\n\n  describe('Optimistic Updates', () => {\n    it('handles optimistic updates correctly', async () => {\n      // This would test optimistic update behavior\n      // Implementation depends on how optimistic updates are set up\n      const { result } = renderHook(() => useUpdateMemory(), {\n        wrapper: createWrapper()\n      })\n\n      // Test would verify that UI updates immediately\n      // and rolls back on error\n      expect(result.current.mutate).toBeDefined()\n    })\n  })\n\n  describe('Cache Invalidation', () => {\n    it('invalidates cache after successful mutation', async () => {\n      // This would test that the memories list is refetched\n      // after successful create/update/delete operations\n      const { result } = renderHook(() => useCreateMemory(), {\n        wrapper: createWrapper()\n      })\n\n      mockMcpAdapter.memory.createMemory.mockResolvedValueOnce(mockMemory())\n\n      result.current.mutate({\n        title: 'Test',\n        content: 'Test',\n        tags: []\n      })\n\n      await waitFor(() => {\n        expect(result.current.isSuccess).toBe(true)\n      })\n\n      // Would verify that useMemories queries are invalidated\n    })\n  })\n})"